diff --git a/equity_connect/agent/barbara_agent.py b/equity_connect/agent/barbara_agent.py
index 2ed4a8b..d91a987 100644
--- a/equity_connect/agent/barbara_agent.py
+++ b/equity_connect/agent/barbara_agent.py
@@ -60,10 +60,10 @@ class BarbaraAgent(AgentBase):
 		self.set_web_hook_url("https://barbara-agent.fly.dev/swaig")
 		self.set_post_prompt_url("https://barbara-agent.fly.dev/post_prompt")
 		
-		# DYNAMIC CONFIG: TEMPORARILY DISABLED
-		# Re-enable this once simplified testing is complete
-		# self.set_dynamic_config_callback(self.configure_per_call)
-		logger.info("‚ö†Ô∏è Dynamic config callback DISABLED - using hardcoded contexts for testing")
+		# DYNAMIC CONFIG: Load contexts per-call from database
+		# This enables instant prompt updates without redeploying
+		self.set_dynamic_config_callback(self.configure_per_call)
+		logger.info("‚úÖ Dynamic config callback ENABLED - will load contexts + caller info per call")
 		
 		# Static configuration (applied once at initialization)
 		# These don't change per-call, so set them here instead of configure_per_call
@@ -99,103 +99,11 @@ class BarbaraAgent(AgentBase):
 		self.add_pronunciation("AI", "A I", ignore_case=False)
 		
 		# ==================================================================
-		# FALLBACK CONTEXTS - Safety net if DB fails
-		# These are minimal contexts used ONLY if database loading fails
-		# Normal operation loads contexts from DB in configure_per_call()
+		# NO HARDCODED CONTEXTS - All contexts loaded in configure_per_call()
+		# This prevents recursion and enables instant DB updates
 		# ==================================================================
 		
-		# Add a simple personality prompt
-		self.prompt_add_section(
-			"Personality",
-			"You are Barbara, a professional assistant for Equity Connect. "
-			"You help people with reverse mortgage questions."
-		)
-		
-		contexts = self.define_contexts()
-		default_context = contexts.add_context("default")
-		
-		# GREET - Entry point
-		default_context.add_step("greet") \
-			.add_section("Instructions", 
-				"You are Barbara. Your ONLY job:\n"
-				"1. Greet the caller:\n"
-				"   - Check CALLER INFORMATION section above\n"
-				"   - If Name is shown: 'Hi [use their first name]! This is Barbara with Equity Connect. How can I help you today?'\n"
-				"   - If Name is Unknown or missing: 'Hi! This is Barbara with Equity Connect. How can I help you today?'\n"
-				"2. If they ask ANY question, IMMEDIATELY call route_to_answer_for_question(user_question='their question')\n"
-				"That's it. Nothing else."
-			) \
-			.set_step_criteria("Greeted caller") \
-			.set_functions(["route_to_answer_for_question", "mark_wrong_person"]) \
-			.set_valid_steps(["answer"])
-		
-		# ANSWER - Question handling
-		default_context.add_step("answer") \
-			.add_section("Instructions",
-				"You are in ANSWER context. Your job:\n"
-				"1. Call search_knowledge(query='user's question') to get the answer\n"
-				"2. Give them the answer\n"
-				"3. Ask: 'Any other questions?'\n"
-				"4. If they say 'I'm ready to book' or 'let's schedule': call complete_questions(next_context='book')\n"
-				"5. If they say NO (no more questions): call complete_questions(next_context='goodbye')\n"
-				"6. If they say YES (have more questions): wait for their next question and repeat from step 1"
-			) \
-			.set_step_criteria("User confirmed no more questions OR ready to book") \
-			.set_functions(["search_knowledge", "complete_questions"]) \
-			.set_valid_steps(["goodbye", "book"])
-		
-		# BOOK - Appointment scheduling
-		default_context.add_step("book") \
-			.add_section("Instructions",
-				"You are in BOOK context. Your job:\n"
-				"1. Say: 'Great! Let me check Walter Richards' calendar.'\n"
-				"2. Call check_broker_availability(broker_id, preferred_day, preferred_time)\n"
-				"3. Present 2-3 available time slots\n"
-				"4. When they pick one, call book_appointment(lead_id, broker_id, scheduled_for, notes)\n"
-				"5. Confirm: 'Perfect! You're all set for [day] at [time]'\n"
-				"6. Route to GOODBYE"
-			) \
-			.set_step_criteria("Appointment booked or declined") \
-			.set_functions(["check_broker_availability", "book_appointment"]) \
-			.set_valid_steps(["goodbye"])
-		
-		# GOODBYE - Natural farewell (user-facing)
-		default_context.add_step("goodbye") \
-			.add_section("Instructions",
-				"You are in GOODBYE context. Your job:\n"
-				"1. Say goodbye using the broker name from CALLER INFORMATION:\n"
-				"   - Check 'Assigned Broker:' in CALLER INFORMATION section above\n"
-				"   - If broker name is shown: 'Thanks for your time! [use that broker name] will reach out soon. Have a great day!'\n"
-				"   - If no broker shown: 'Thanks for your time! Your assigned broker will reach out soon. Have a great day!'\n"
-				"2. Wait for their response\n"
-				"3. If they ask ANY question, call route_to_answer_for_question(user_question='their question')\n"
-				"4. If they say 'thank you', 'bye', 'goodbye', or stay silent: do nothing (call will end automatically)\n"
-				"Don't explicitly say goodbye again, just let the call end naturally."
-			) \
-			.set_step_criteria("Said farewell and caller responded or stayed silent") \
-			.set_functions(["route_to_answer_for_question"]) \
-			.set_valid_steps(["answer", "end"])
-		
-		# END - Hidden system node (actual hangup)
-		default_context.add_step("end") \
-			.add_section("Instructions",
-				"Call is ending. No action needed."
-			) \
-			.set_step_criteria("Call complete") \
-			.set_functions([]) \
-			.set_valid_steps([])
-		
-		logger.info("‚úÖ HARDCODED CONTEXTS loaded - bypassing database for testing")
-		
-		# Voice configuration (hardcoded for testing)
-		# Default: ElevenLabs Rachel (female voice)
-		self.add_language(
-			name="English",
-			code="en-US",
-			voice="elevenlabs.rachel",  # Female voice
-			engine="elevenlabs"
-		)
-		logger.info("‚úÖ Voice set to ElevenLabs Rachel (female)")
+		logger.info("‚úÖ BarbaraAgent initialized - contexts will be loaded per-call from configure_per_call()")
 		
 		# Pattern hints
 		self.add_pattern_hint(
@@ -269,11 +177,17 @@ List specific actions needed based on conversation outcome.
 		Returns dict with context_name -> config mapping, or None if failed
 		"""
 		try:
+			from equity_connect.services.supabase import get_supabase_client
+			sb = get_supabase_client()
+			
 			# Use timeout protection for DB query
 			def query_db():
-				response = self.supabase.table('prompt_versions') \
-					.select('context_name, content') \
-					.eq('version', 'active') \
+				# Join prompts + prompt_versions to get node_name + content
+				response = sb.table('prompts') \
+					.select('node_name, prompt_versions!inner(content, is_active)') \
+					.eq('vertical', 'reverse_mortgage') \
+					.eq('is_active', True) \
+					.eq('prompt_versions.is_active', True) \
 					.execute()
 				return response.data
 			
@@ -286,7 +200,12 @@ List specific actions needed based on conversation outcome.
 			
 			configs = {}
 			for row in data:
-				configs[row['context_name']] = row['content']
+				node_name = row['node_name']
+				# prompt_versions is an array of version objects
+				versions = row.get('prompt_versions', [])
+				if versions and len(versions) > 0:
+					# Get the first active version's content
+					configs[node_name] = versions[0]['content']
 			
 			logger.info(f"‚úÖ Loaded {len(configs)} contexts from database: {list(configs.keys())}")
 			return configs
@@ -301,15 +220,18 @@ List specific actions needed based on conversation outcome.
 		Returns config dict from theme_prompts.config, or None if failed
 		"""
 		try:
+			from equity_connect.services.supabase import get_supabase_client
+			sb = get_supabase_client()
+			
 			# Use timeout protection for DB query
 			def query_db():
-				response = self.supabase.table('theme_prompts') \
+				response = sb.table('theme_prompts') \
 					.select('config') \
 					.eq('vertical', 'reverse_mortgage') \
 					.eq('is_active', True) \
-					.maybeSingle() \
+					.limit(1) \
 					.execute()
-				return response.data
+				return response.data[0] if response.data else None
 			
 			# 3 second timeout for DB query
 			data = self._execute_with_timeout(query_db, timeout_seconds=3)
@@ -405,14 +327,49 @@ List specific actions needed based on conversation outcome.
 		This runs on every call and loads the latest prompts from the database,
 		allowing instant updates without redeploying the agent.
 		"""
-		logger.info("üîÑ Loading fresh contexts from database for this call...")
+		logger.info("üîÑ configure_per_call() started - loading contexts + caller info...")
+		
+		# STEP 1: Extract phone number and load caller info
+		phone = self._extract_phone_from_params(query_params, body_params)
+		lead_data = None
+		conv_state = None
+		
+		if phone:
+			logger.info(f"[CONFIG] Loading caller info for: {phone}")
+			
+			# Normalize phone number (remove +1 prefix for DB lookup)
+			normalized_phone = phone.lstrip('+1') if phone.startswith('+1') else phone.lstrip('+')
+			logger.info(f"[CONFIG] Normalized phone for DB: {normalized_phone}")
+			
+			# Query lead data from database
+			from equity_connect.services.supabase import get_supabase_client
+			sb = get_supabase_client()
+			
+			def query_lead():
+				response = sb.table('leads') \
+					.select('*') \
+					.eq('primary_phone', normalized_phone) \
+					.limit(1) \
+					.execute()
+				return response.data[0] if response.data else None
+			
+			lead_data = self._execute_with_timeout(query_lead, timeout_seconds=3)
+			conv_state = get_conversation_state(phone)
+			
+			if lead_data:
+				logger.info(f"[CONFIG] Found lead: {lead_data.get('first_name')} {lead_data.get('last_name')}")
+				self._inject_caller_info_into_personality(agent, phone, lead_data, conv_state)
+			else:
+				logger.info(f"[CONFIG] No lead found for {phone}")
+		else:
+			logger.warning("[CONFIG] No phone number found - using generic setup")
 		
-		# Load configs from DB
+		# STEP 2: Load configs from DB
 		db_configs = self._load_context_configs_from_db()
 		
 		if not db_configs:
-			logger.warning("‚ö†Ô∏è Using hardcoded fallback contexts from __init__")
-			return  # Use the hardcoded ones from __init__ as fallback
+			logger.error("‚ùå No contexts found in database - cannot proceed")
+			raise ValueError("No active contexts found in database for reverse_mortgage")  # Fail fast
 		
 		# Load theme configuration (LLM, STT, VAD, recording settings)
 		theme_config = self._load_theme_config_from_db()
@@ -426,31 +383,16 @@ List specific actions needed based on conversation outcome.
 		voice_string = self._build_voice_string(voice_config["engine"], voice_config["voice_name"])
 		logger.info(f"‚úÖ Loaded voice config: {voice_string} ({voice_config['engine']})")
 		
-		# Apply agent parameters to the agent
-		agent.set_attention_timeout(agent_params.get("attention_timeout", 8000))
-		if agent_params.get("attention_timeout_prompt"):
-			agent.set_attention_timeout_prompt(agent_params["attention_timeout_prompt"])
-		
-		agent.set_end_of_speech_timeout(agent_params.get("end_of_speech_timeout", 800))
-		
-		if agent_params.get("hard_stop_time"):
-			agent.set_hard_stop(agent_params["hard_stop_time"])
-		if agent_params.get("hard_stop_prompt"):
-			agent.set_hard_stop_prompt(agent_params["hard_stop_prompt"])
-		
-		agent.set_first_word_timeout(agent_params.get("first_word_timeout", 1000))
-		
-		if agent_params.get("acknowledge_interruptions"):
-			agent.set_acknowledge_interruptions(agent_params["acknowledge_interruptions"])
-		if agent_params.get("interrupt_prompt"):
-			agent.set_interrupt_prompt(agent_params["interrupt_prompt"])
-		
-		agent.set_transparent_barge(agent_params.get("transparent_barge", False))
-		
-		if agent_params.get("enable_barge"):
-			agent.set_barge_confidence(agent_params["enable_barge"])
+		# Apply agent parameters to the agent using set_params() (old working pattern)
+		agent.set_params({
+			"attention_timeout": agent_params.get("attention_timeout", 8000),
+			"end_of_speech_timeout": agent_params.get("end_of_speech_timeout", 800),
+			"first_word_timeout": agent_params.get("first_word_timeout", 1000),
+			"transparent_barge": agent_params.get("transparent_barge", False),
+		})
+		logger.info(f"‚úÖ Applied agent params via set_params()")
 		
-		# Apply voice configuration
+		# Apply voice configuration using add_language (old working pattern)
 		language_params = {
 			"name": voice_config.get("language_name", "English"),
 			"code": voice_config.get("language_code", "en-US"),
@@ -461,8 +403,8 @@ List specific actions needed based on conversation outcome.
 		if voice_config.get("model"):
 			language_params["model"] = voice_config["model"]
 		
-		# Set the language with voice config
-		agent.set_language(language_params)
+		# Use add_language (from old code), NOT set_language
+		agent.add_language(**language_params)
 		
 		logger.info(f"‚úÖ Applied voice & VAD settings for this call")
 		
@@ -496,6 +438,135 @@ List specific actions needed based on conversation outcome.
 		
 		logger.info(f"‚úÖ All {len(db_configs)} contexts loaded from database for this call")
 	
+	def _extract_phone_from_params(self, query_params: Dict[str, Any], body_params: Dict[str, Any]) -> Optional[str]:
+		"""Extract phone number from request parameters
+		
+		SignalWire passes call info in query_params['call'] (JSON string or dict)
+		"""
+		phone = None
+		
+		# Try query_params['call'] first (SignalWire's location)
+		if query_params and 'call' in query_params:
+			call_data = query_params['call']
+			
+			# Handle if it's a JSON string
+			if isinstance(call_data, str):
+				try:
+					call_data = json.loads(call_data)
+					logger.info(f"[CONFIG] Parsed query_params['call'] from JSON string")
+				except:
+					pass
+			
+			# Extract from dict
+			if isinstance(call_data, dict) and 'from' in call_data:
+				phone = call_data['from']
+				logger.info(f"[CONFIG] ‚úÖ Found phone in query_params['call']['from']: {phone}")
+		
+		# Fallback: try body_params (for other request types)
+		if not phone and body_params:
+			if 'call' in body_params and isinstance(body_params['call'], dict) and 'from' in body_params['call']:
+				phone = body_params['call']['from']
+			elif 'From' in body_params:
+				phone = body_params['From']
+			elif 'caller_id_num' in body_params:
+				phone = body_params['caller_id_num']
+		
+		return phone
+	
+	def _inject_caller_info_into_personality(self, agent, phone: str, lead_data: Dict[str, Any], conv_state: Optional[Dict[str, Any]]):
+		"""Inject caller information into Personality section
+		
+		Combines personality + caller data into one section optimized for GPT-4o-mini
+		"""
+		conversation_data = conv_state.get('conversation_data', {}) if conv_state else {}
+		qualified = conv_state.get('qualified') if conv_state else None
+		
+		# Build caller info block
+		caller_info = "\n\n=== CALLER INFORMATION ===\n"
+		caller_info += f"Name: {lead_data.get('first_name', 'Unknown')} {lead_data.get('last_name', '')}\n"
+		caller_info += f"Phone: {phone}\n"
+		
+		# Property information
+		if lead_data.get('property_address'):
+			caller_info += f"Property: {lead_data.get('property_address')}\n"
+		elif lead_data.get('property_city') and lead_data.get('property_state'):
+			caller_info += f"Property: {lead_data.get('property_city')}, {lead_data.get('property_state')}\n"
+		
+		# Financial information
+		if lead_data.get('property_value'):
+			caller_info += f"Property Value: ${lead_data.get('property_value'):,}\n"
+		if lead_data.get('estimated_equity'):
+			caller_info += f"Estimated Equity: ${lead_data.get('estimated_equity'):,}\n"
+		if lead_data.get('mortgage_balance'):
+			caller_info += f"Mortgage Balance: ${lead_data.get('mortgage_balance'):,}\n"
+		
+		# Demographics
+		if lead_data.get('age'):
+			caller_info += f"Age: {lead_data.get('age')}\n"
+		
+		# Qualification status
+		if qualified is True:
+			caller_info += "Status: ‚úÖ QUALIFIED for reverse mortgage\n"
+		elif qualified is False:
+			caller_info += "Status: ‚ùå Does NOT qualify\n"
+		
+		# Call history
+		if conversation_data.get('quote_presented'):
+			quote_reaction = conversation_data.get('quote_reaction', 'unknown')
+			caller_info += f"Previous Quote: Presented (reaction: {quote_reaction})\n"
+		if conversation_data.get('appointment_booked'):
+			appt_id = conversation_data.get('appointment_id', 'N/A')
+			caller_info += f"Appointment: ‚úÖ BOOKED (ID: {appt_id})\n"
+		elif conversation_data.get('ready_to_book'):
+			caller_info += "Intent: Ready to book appointment\n"
+		if conversation_data.get('has_objections') and not conversation_data.get('objection_handled'):
+			objection_type = conversation_data.get('last_objection_type', 'unknown')
+			caller_info += f"Objection: ‚ö†Ô∏è Unresolved ({objection_type})\n"
+		
+		# Broker info
+		broker_id = lead_data.get('broker_id')
+		if broker_id:
+			broker_name = lead_data.get('broker_name', 'Walter Richards')
+			caller_info += f"Assigned Broker: {broker_name}\n"
+		
+		caller_info += "========================\n"
+		
+		# Combine personality + caller info
+		combined_personality = (
+			"You are Barbara, a professional assistant for Equity Connect.\n"
+			"You help people with reverse mortgage questions.\n"
+			"Be warm, friendly, patient, and senior-friendly.\n"
+			f"{caller_info}"
+		)
+		
+		# Inject into agent
+		agent.prompt_add_section("Personality", combined_personality)
+		
+		# Set global_data for tools
+		agent.set_global_data({
+			"company_name": "Barbara AI",
+			"service_type": "Reverse Mortgage Assistance",
+			"lead_id": lead_data.get('id'),
+			"lead_phone": phone,
+			"first_name": lead_data.get('first_name'),
+			"last_name": lead_data.get('last_name'),
+			"property_address": lead_data.get('property_address'),
+			"property_city": lead_data.get('property_city'),
+			"property_state": lead_data.get('property_state'),
+			"property_value": lead_data.get('property_value'),
+			"estimated_equity": lead_data.get('estimated_equity'),
+			"mortgage_balance": lead_data.get('mortgage_balance'),
+			"age": lead_data.get('age'),
+			"qualified": qualified,
+			"quote_presented": conversation_data.get('quote_presented', False),
+			"appointment_booked": conversation_data.get('appointment_booked', False),
+			"ready_to_book": conversation_data.get('ready_to_book', False),
+			"broker_id": broker_id,
+			"broker_name": lead_data.get('broker_name', 'Your assigned broker')
+		})
+		
+		logger.info(f"[CONFIG] ‚úÖ Caller info injected: {lead_data.get('first_name')}, broker={lead_data.get('broker_name')}")
+	
 	def _log_context_change(self, step_name: str, previous_step: str = None):
 		"""Callback to log when context/step changes"""
 		if previous_step:
@@ -2183,147 +2254,30 @@ List specific actions needed based on conversation outcome.
 	# ==================== END TOOL DEFINITIONS ====================
 	
 	def on_swml_request(self, query_params: Dict[str, Any], body_params: Dict[str, Any], headers: Dict[str, Any]):
-		"""Override to inject caller info into prompts BEFORE call starts
+		"""Override to log request info (actual config is in configure_per_call)
 		
-		This runs once per call BEFORE the agent starts speaking.
-		We use it to load caller info and inject it into the personality prompt.
+		NOTE: Caller info injection now happens in configure_per_call(), not here.
+		This is just for debugging/logging.
 		"""
 		try:
-			# Extract phone number from request
-			phone = None
-			if body_params and 'call' in body_params and 'from' in body_params['call']:
-				phone = body_params['call']['from']
-			elif body_params and 'From' in body_params:
-				phone = body_params['From']
-			elif body_params and 'caller_id_num' in body_params:
-				phone = body_params['caller_id_num']
-			
-			if not phone:
-				logger.warning("[SWML] No phone number found in request, using generic greeting")
-				return super().on_swml_request(query_params, body_params, headers)
-			
-			logger.info(f"[SWML] Loading caller info for: {phone}")
-			
-			# Query lead by phone
-			lead_data = lead_service.query_lead_direct(phone)
-			
-			# Also get conversation state for call history
-			conv_state = get_conversation_state(phone)
-			conversation_data = conv_state.get('conversation_data', {}) if conv_state else {}
-			
-			if lead_data:
-				logger.info(f"[SWML] Found lead: {lead_data.get('first_name')} {lead_data.get('last_name')}")
-				
-				# Build caller context string
-				caller_info = f"""
-				
-=== CALLER INFORMATION ===
-Name: {lead_data.get('first_name', 'Unknown')} {lead_data.get('last_name', '')}
-Phone: {phone}
-"""
-				
-				# Property information
-				if lead_data.get('property_address'):
-					caller_info += f"Property: {lead_data.get('property_address')}\n"
-				elif lead_data.get('property_city') and lead_data.get('property_state'):
-					caller_info += f"Property: {lead_data.get('property_city')}, {lead_data.get('property_state')}\n"
-				
-				# Financial information
-				if lead_data.get('property_value'):
-					caller_info += f"Property Value: ${lead_data.get('property_value'):,}\n"
-				
-				if lead_data.get('estimated_equity'):
-					caller_info += f"Estimated Equity: ${lead_data.get('estimated_equity'):,}\n"
-				
-				if lead_data.get('mortgage_balance'):
-					caller_info += f"Mortgage Balance: ${lead_data.get('mortgage_balance'):,}\n"
-				
-				# Demographics
-				if lead_data.get('age'):
-					caller_info += f"Age: {lead_data.get('age')}\n"
-				
-				# Qualification status
-				qualified = conv_state.get('qualified') if conv_state else None
-				if qualified is True:
-					caller_info += f"Status: ‚úÖ QUALIFIED for reverse mortgage\n"
-				elif qualified is False:
-					caller_info += f"Status: ‚ùå Does NOT qualify\n"
-				
-				# Call history
-				if conversation_data.get('quote_presented'):
-					quote_reaction = conversation_data.get('quote_reaction', 'unknown')
-					caller_info += f"Previous Quote: Presented (reaction: {quote_reaction})\n"
-				
-				if conversation_data.get('appointment_booked'):
-					appt_id = conversation_data.get('appointment_id', 'N/A')
-					caller_info += f"Appointment: ‚úÖ BOOKED (ID: {appt_id})\n"
-				elif conversation_data.get('ready_to_book'):
-					caller_info += f"Intent: Ready to book appointment\n"
-				
-				if conversation_data.get('questions_answered'):
-					caller_info += f"Questions: All answered\n"
-				
-				if conversation_data.get('has_objections') and not conversation_data.get('objection_handled'):
-					objection_type = conversation_data.get('last_objection_type', 'unknown')
-					caller_info += f"Objection: ‚ö†Ô∏è Unresolved ({objection_type})\n"
-				
-				# Add broker info if assigned
-				broker_id = lead_data.get('broker_id')
-				if broker_id:
-					broker_name = lead_data.get('broker_name', 'Walter Richards')
-					caller_info += f"Assigned Broker: {broker_name}\n"
-				
-				caller_info += "========================\n"
-				
-				# Inject into personality prompt (update the section)
-				self.prompt_add_section(
-					"Caller Info",
-					caller_info
-				)
-				
-				# Also set global_data so tools can access it
-				self.set_global_data({
-					"company_name": "Barbara AI",
-					"service_type": "Reverse Mortgage Assistance",
-					"lead_id": lead_data.get('id'),
-					"lead_phone": phone,
-					"first_name": lead_data.get('first_name'),
-					"last_name": lead_data.get('last_name'),
-					"property_address": lead_data.get('property_address'),
-					"property_city": lead_data.get('property_city'),
-					"property_state": lead_data.get('property_state'),
-					"property_value": lead_data.get('property_value'),
-					"estimated_equity": lead_data.get('estimated_equity'),
-					"mortgage_balance": lead_data.get('mortgage_balance'),
-					"age": lead_data.get('age'),
-					"qualified": qualified,
-					"quote_presented": conversation_data.get('quote_presented', False),
-					"quote_reaction": conversation_data.get('quote_reaction'),
-					"appointment_booked": conversation_data.get('appointment_booked', False),
-					"appointment_id": conversation_data.get('appointment_id'),
-					"ready_to_book": conversation_data.get('ready_to_book', False),
-					"questions_answered": conversation_data.get('questions_answered', False),
-					"has_objections": conversation_data.get('has_objections', False),
-					"objection_handled": conversation_data.get('objection_handled', False),
-					"broker_id": broker_id,
-					"broker_name": lead_data.get('broker_name', 'Walter Richards')
-				})
-				
-				logger.info(f"[SWML] ‚úÖ Caller info injected into prompt and global_data")
-			else:
-				logger.info(f"[SWML] No lead found for {phone}, using generic greeting")
-				# Set minimal global_data
-				self.set_global_data({
-					"company_name": "Barbara AI",
-					"service_type": "Reverse Mortgage Assistance",
-					"lead_phone": phone
-				})
+			# DEBUG: Log request structure
+			logger.info(f"[SWML] on_swml_request() called")
+			logger.info(f"[SWML DEBUG] query_params keys: {list(query_params.keys()) if query_params else 'None'}")
+			logger.info(f"[SWML DEBUG] body_params keys: {list(body_params.keys()) if body_params else 'None'}")
+			
+			# Log call data if present
+			if query_params and 'call' in query_params:
+				call_data = query_params['call']
+				logger.info(f"[SWML DEBUG] query_params['call'] type: {type(call_data)}")
+				if isinstance(call_data, dict):
+					logger.info(f"[SWML DEBUG] query_params['call'] keys: {list(call_data.keys())}")
+					if 'from' in call_data:
+						logger.info(f"[SWML DEBUG] ‚úÖ Found phone in query_params['call']['from']: {call_data['from']}")
 		
 		except Exception as e:
-			logger.error(f"[SWML] Error loading caller info: {e}")
-			# Don't fail the call, just continue without caller info
+			logger.error(f"[SWML] Error in on_swml_request: {e}")
 		
-		# Call parent implementation to continue normal flow
+		# Call parent implementation
 		return super().on_swml_request(query_params, body_params, headers)
 	
 	def on_summary(self, summary: Optional[Dict[str, Any]], raw_data: Optional[Dict[str, Any]] = None):
