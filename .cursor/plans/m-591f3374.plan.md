<!-- 591f3374-9040-4079-bcfd-bffa62476d7a 16a16f20-5447-428f-8db1-1119adf8871b -->
# Fix SignalWire SDK Integration

## Problem Summary

The current implementation has placeholder code that doesn't use SignalWire SDK correctly:

- Tool registration uses custom `_try_register` instead of SignalWire's `define_tool()`
- Agent class has fallback logic but doesn't properly inherit from `AgentBase`
- App.py is a basic HTTP server instead of using SignalWire's built-in server
- BarbGraph routing not integrated with SignalWire event system
- Prompt loading not using SignalWire's prompt methods

## Implementation Plan

### 1. Fix Tool Registration in [`equity_connect/tools/registry.py`](equity_connect/tools/registry.py)

**Replace custom `_try_register` with SignalWire's `define_tool` API:**

Current (lines 6-44):

```python
def _try_register(agent, name, description, parameters, handler):
    # Custom registration logic with fallbacks
```

Change to:

```python
def register_all_tools(agent):
    """Register all 21 tools using SignalWire's define_tool API"""
    from signalwire_agents.core.function_result import SwaigFunctionResult
    
    # Each tool uses define_tool() per SDK docs
    agent.define_tool(
        name="get_lead_context",
        description="Get lead information by phone number",
        parameters={"type": "object", "properties": {...}, "required": [...]},
        handler=lambda args, raw_data: get_lead_context(args.get("phone"))
    )
    # ... repeat for all 21 tools
```

Key changes:

- Use `agent.define_tool()` directly (no fallback logic needed)
- Handler signature is `(args: Dict, raw_data: Dict) -> SwaigFunctionResult`
- All tools return string results (no SwaigFunctionResult needed for simple responses)

### 2. Refactor BarbaraAgent in [`equity_connect/agent/equity_connect_agent.py`](equity_connect/agent/equity_connect_agent.py)

**Properly inherit from `AgentBase` and wire BarbGraph routing:**

Replace entire file with:

```python
from signalwire_agents import AgentBase, SwaigFunctionResult
from equity_connect.tools.registry import register_all_tools
from equity_connect.services.prompt_loader import build_instructions_for_node
from equity_connect.services.conversation_state import get_conversation_state, extract_phone_from_messages
from equity_connect.workflows.routers import (
    route_after_greet, route_after_verify, route_after_qualify,
    route_after_answer, route_after_quote, route_after_objection,
    route_after_book, route_after_confirm
)
from equity_connect.workflows.node_completion import is_node_complete

class BarbaraAgent(AgentBase):
    def __init__(self):
        super().__init__(
            name="barbara-agent",
            route="/agent",
            port=8080,
            auto_answer=True,
            record_call=True,
            record_format="mp3"
        )
        
        # Set up voice and AI params
        self.add_language("English", "en-US", "rime.spore",
            speech_fillers=["Let me check on that...", "One moment please..."],
            function_fillers=["Looking that up...", "Processing..."]
        )
        
        self.set_params({
            "end_of_speech_timeout": 800,
            "attention_timeout": 30000,
            "temperature": 0.7
        })
        
        # Register all 21 tools
        register_all_tools(self)
        
        # Start at greet node
        self.current_node = "greet"
        self.phone_number = None
        
        # Load initial greet node prompt
        self._load_node_sync("greet")
    
    def _load_node_sync(self, node_name: str):
        """Load node prompt synchronously during init"""
        instructions = build_instructions_for_node(
            node_name=node_name,
            call_type="outbound",  # Will be updated from call context
            lead_context=None,
            phone_number=self.phone_number
        )
        self.set_prompt_text(instructions)
        self.current_node = node_name
    
    def on_summary(self, summary, raw_data):
        """Called when conversation completes - save final state"""
        # Extract phone from conversation for state update
        # Log summary to database via save_interaction tool
        pass
    
    def on_function_call(self, name: str, args: dict, raw_data: dict):
        """Intercept tool calls to trigger routing after completion"""
        # Let the tool execute normally
        result = super().on_function_call(name, args, raw_data)
        
        # After tool completes, check routing
        self._check_and_route_after_tool(name, args)
        
        return result
    
    def _check_and_route_after_tool(self, tool_name: str, args: dict):
        """Check if we should route after a tool call"""
        # Extract phone from args (most tools have phone parameter)
        phone = args.get("phone") or self.phone_number
        if not phone:
            return
        
        # Get current conversation state
        state_row = get_conversation_state(phone)
        if not state_row:
            return
        
        # Check if current node is complete
        if is_node_complete(self.current_node, state_row.get("conversation_data", {})):
            next_node = self._get_next_node(state_row)
            if next_node and next_node != self.current_node:
                self._route_to_node(next_node)
    
    def _get_next_node(self, state_row: dict) -> str:
        """Determine next node using BarbGraph routers"""
        node = self.current_node
        
        # Use appropriate router based on current node
        router_map = {
            "greet": route_after_greet,
            "verify": route_after_verify,
            "qualify": route_after_qualify,
            "answer": route_after_answer,
            "quote": route_after_quote,
            "objection": route_after_objection,
            "book": route_after_book,
            "confirm": route_after_confirm
        }
        
        router = router_map.get(node)
        if router:
            # Convert state_row to ConversationState format
            conv_state = {
                "phone_number": state_row.get("phone_number"),
                "messages": [],  # Not needed for routing
                "conversation_data": state_row.get("conversation_data", {})
            }
            return router(conv_state)
        
        return node  # Stay on current node
    
    def _route_to_node(self, node_name: str):
        """Load new node prompt and update agent instructions"""
        instructions = build_instructions_for_node(
            node_name=node_name,
            call_type=self.ctx.get("call_type", "outbound"),
            lead_context=self.ctx.get("lead_context"),
            phone_number=self.phone_number
        )
        
        # Update prompt using SignalWire API
        self.set_prompt_text(instructions)
        self.current_node = node_name
```

Key changes:

- Proper `AgentBase` initialization with all required params
- Use `set_prompt_text()` for prompt updates (per SDK docs)
- `on_function_call()` hook to trigger routing after tools complete
- BarbGraph routers called after each tool to check for transitions
- Node completion checkers determine when to route

### 3. Fix App Entry Point in [`equity_connect/app.py`](equity_connect/app.py)

**Use SignalWire's built-in server instead of custom HTTP server:**

Replace entire file with:

```python
import logging
import os
from equity_connect.agent.equity_connect_agent import BarbaraAgent

logging.basicConfig(level=os.getenv("LOG_LEVEL", "INFO"))
logger = logging.getLogger(__name__)

if __name__ == "__main__":
    logger.info("Starting Barbara agent...")
    agent = BarbaraAgent()
    agent.run()  # Auto-detects environment (server/lambda/etc)
```

SignalWire's `agent.run()` automatically:

- Sets up HTTP server on port 8080
- Handles `/agent` endpoint for SIP routing
- Provides `/healthz` endpoint (Fly.io health checks work automatically)

### 4. Update Prompt Loader in [`equity_connect/services/prompt_loader.py`](equity_connect/services/prompt_loader.py)

**Add `build_instructions_for_node()` function used by agent:**

Add new function (around line 200):

```python
def build_instructions_for_node(
    node_name: str,
    call_type: str = "outbound",
    lead_context: Optional[str] = None,
    phone_number: Optional[str] = None,
    vertical: str = "reverse_mortgage"
) -> str:
    """Build complete instructions for a node (theme + context + node prompt)
    
    This is the main function called by BarbaraAgent to get full prompt text.
    
    Args:
        node_name: Current conversation node (greet, verify, qualify, etc.)
        call_type: "inbound" or "outbound"
        lead_context: Optional lead info to inject
        phone_number: Caller's phone number
        vertical: Business vertical (default: reverse_mortgage)
    
    Returns:
        Complete prompt text ready for agent.set_prompt_text()
    """
    # 1. Load theme (universal personality)
    theme = load_theme(vertical)
    
    # 2. Load node-specific prompt
    node_prompt = load_node_prompt(node_name, vertical)
    
    # 3. Build context injection
    context = build_context_injection(call_type, lead_context, phone_number)
    
    # 4. Combine: Theme → Context → Node
    parts = [theme]
    if context:
        parts.append(f"\n## Current Call Context\n{context}")
    parts.append(f"\n{node_prompt}")
    
    return "\n".join(parts)
```

This function already exists in concept, just needs to be explicit and return plain text for `set_prompt_text()`.

### 5. Update Requirements in [`equity_connect/requirements.txt`](equity_connect/requirements.txt)

Ensure correct SignalWire SDK version:

```
signalwire-agents>=0.2.0
uvicorn>=0.24.0
# ... rest unchanged
```

## Testing Checklist

After changes:

1. Deploy to Fly.io via GitHub Actions
2. Check health endpoint: `curl https://barbara-agent.fly.dev/healthz`
3. Check agent endpoint: `curl https://barbara-agent.fly.dev/agent`
4. Point SignalWire Voice App to `https://barbara-agent.fly.dev/agent`
5. Make test call through SignalWire SIP
6. Verify all 21 tools register (check logs)
7. Verify BarbGraph routing triggers (check transition logs)
8. Verify prompts load from Supabase (check theme/node logs)

## Migration Notes

**What stays unchanged:**

- All 21 tool business logic (lead.py, calendar.py, etc.) - ZERO changes
- All 8 BarbGraph routers (routers.py) - ZERO changes
- All 8 node completion checkers (node_completion.py) - ZERO changes
- Supabase schema and queries - ZERO changes
- Prompt loading from database - ZERO changes

**What changes:**

- Tool registration mechanism (decorator → define_tool API)
- Agent class structure (proper AgentBase inheritance)
- Prompt update method (custom → set_prompt_text)
- App server (custom HTTP → SignalWire's run())
- Routing trigger (manual → on_function_call hook)

### To-dos

- [ ] Refactor registry.py to use SignalWire's define_tool() API for all 21 tools
- [ ] Rewrite BarbaraAgent to properly inherit from AgentBase with BarbGraph routing
- [ ] Replace custom HTTP server in app.py with SignalWire's agent.run()
- [ ] Add build_instructions_for_node() function to prompt_loader.py
- [ ] Deploy via GitHub Actions and test health, agent endpoint, and tool registration