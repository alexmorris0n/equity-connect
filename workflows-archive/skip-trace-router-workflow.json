{
  "name": "Multi-Provider Skip Trace Router",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "*/5 * * * *"
            }
          ]
        }
      },
      "id": "schedule-trigger",
      "name": "Process Queue Every 5 Min",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.1,
      "position": [240, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT q.*, l.first_name, l.last_name, l.property_address, l.property_city, l.property_state, l.property_zip, l.phone, l.email\nFROM skip_trace_queue q\nJOIN leads l ON q.lead_id = l.id\nWHERE q.status = 'pending'\n  AND (q.started_at IS NULL OR q.started_at < NOW() - INTERVAL '10 minutes')\nORDER BY q.priority DESC, q.created_at ASC\nLIMIT 10",
        "options": {}
      },
      "id": "get-pending-traces",
      "name": "Get Pending Traces",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.2,
      "position": [460, 300],
      "credentials": {
        "postgres": {
          "id": "supabase_postgres",
          "name": "Supabase Postgres"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false
          },
          "conditions": [
            {
              "id": "has-items",
              "leftValue": "={{ $json.length }}",
              "rightValue": "0",
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ]
        }
      },
      "id": "check-has-items",
      "name": "Check Has Items",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "id": "split-requests",
      "name": "Split Requests",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [900, 200]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT * FROM route_skip_trace_request('{{ $json.id }}'::UUID)",
        "options": {}
      },
      "id": "select-provider",
      "name": "Select Provider",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.2,
      "position": [1120, 200],
      "credentials": {
        "postgres": {
          "id": "supabase_postgres",
          "name": "Supabase Postgres"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "provider_name",
              "name": "provider_name",
              "value": "={{ $json.provider_name }}",
              "type": "string"
            },
            {
              "id": "provider_id",
              "name": "provider_id",
              "value": "={{ $json.provider_id }}",
              "type": "string"
            },
            {
              "id": "api_endpoint",
              "name": "api_endpoint",
              "value": "={{ $json.api_endpoint }}",
              "type": "string"
            },
            {
              "id": "queue_id",
              "name": "queue_id",
              "value": "={{ $('split-requests').item.json.id }}",
              "type": "string"
            },
            {
              "id": "lead_id",
              "name": "lead_id",
              "value": "={{ $('split-requests').item.json.lead_id }}",
              "type": "string"
            },
            {
              "id": "first_name",
              "name": "first_name",
              "value": "={{ $('split-requests').item.json.first_name }}",
              "type": "string"
            },
            {
              "id": "last_name",
              "name": "last_name",
              "value": "={{ $('split-requests').item.json.last_name }}",
              "type": "string"
            },
            {
              "id": "address",
              "name": "address",
              "value": "={{ $('split-requests').item.json.property_address }}",
              "type": "string"
            },
            {
              "id": "city",
              "name": "city",
              "value": "={{ $('split-requests').item.json.property_city }}",
              "type": "string"
            },
            {
              "id": "state",
              "name": "state",
              "value": "={{ $('split-requests').item.json.property_state }}",
              "type": "string"
            },
            {
              "id": "zip",
              "name": "zip",
              "value": "={{ $('split-requests').item.json.property_zip }}",
              "type": "string"
            }
          ]
        }
      },
      "id": "prepare-request",
      "name": "Prepare Request",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.3,
      "position": [1340, 200]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false
          },
          "conditions": [
            {
              "id": "provider-check",
              "leftValue": "={{ $json.provider_name }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ]
        }
      },
      "id": "has-provider",
      "name": "Has Provider?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1560, 200]
    },
    {
      "parameters": {
        "url": "={{ $json.api_endpoint }}",
        "method": "POST",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "first_name",
              "value": "={{ $json.first_name }}"
            },
            {
              "name": "last_name",
              "value": "={{ $json.last_name }}"
            },
            {
              "name": "address",
              "value": "={{ $json.address }}"
            },
            {
              "name": "city",
              "value": "={{ $json.city }}"
            },
            {
              "name": "state",
              "value": "={{ $json.state }}"
            },
            {
              "name": "zip",
              "value": "={{ $json.zip }}"
            }
          ]
        },
        "options": {
          "timeout": 30000
        }
      },
      "id": "call-skip-trace-api",
      "name": "Call Skip Trace API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1780, 100]
    },
    {
      "parameters": {
        "functionCode": "const startTime = Date.now();\nconst request = $('prepare-request').first().json;\nconst apiResponse = $input.first().json;\n\n// Normalize response based on provider\nlet phones = [];\nlet emails = [];\nlet addresses = [];\nlet status = 'no_match';\nlet confidence = 0;\nlet providerPayload = {};\n\n// Provider-specific response parsing\nswitch(request.provider_name) {\n  case 'Melissa Data':\n    phones = apiResponse.Records?.[0]?.PhoneNumber ? [apiResponse.Records[0].PhoneNumber] : [];\n    emails = apiResponse.Records?.[0]?.Email ? [apiResponse.Records[0].Email] : [];\n    confidence = apiResponse.Records?.[0]?.Results?.match(/AS\\d{2}/) ? 95 : 70;\n    status = phones.length || emails.length ? 'success' : 'no_match';\n    providerPayload = { melissa_payload: apiResponse };\n    break;\n    \n  case 'TrueTrace':\n    phones = apiResponse.phones || [];\n    emails = apiResponse.emails || [];\n    confidence = apiResponse.confidence_score || 0;\n    status = apiResponse.match_found ? 'success' : 'no_match';\n    providerPayload = { truetrace_payload: apiResponse };\n    break;\n    \n  case 'Spokeo':\n    phones = apiResponse.phone_numbers || [];\n    emails = apiResponse.emails || [];\n    confidence = apiResponse.accuracy || 0;\n    status = phones.length || emails.length ? 'success' : 'no_match';\n    providerPayload = { spokeo_payload: apiResponse };\n    break;\n    \n  case 'PropStream':\n    const results = apiResponse.results?.[0] || {};\n    phones = results.phone ? [results.phone] : [];\n    emails = results.email ? [results.email] : [];\n    status = phones.length || emails.length ? 'success' : 'no_match';\n    confidence = 75;\n    providerPayload = { propstream_payload: apiResponse };\n    break;\n    \n  default:\n    // Generic parsing\n    phones = apiResponse.phones || apiResponse.phone_numbers || [];\n    emails = apiResponse.emails || apiResponse.email_addresses || [];\n    status = phones.length || emails.length ? 'success' : 'no_match';\n    confidence = apiResponse.confidence || apiResponse.score || 50;\n}\n\nconst responseTime = Date.now() - startTime;\n\nreturn [{\n  json: {\n    queue_id: request.queue_id,\n    lead_id: request.lead_id,\n    provider_id: request.provider_id,\n    provider_name: request.provider_name,\n    status: status,\n    confidence_score: confidence,\n    phones: phones,\n    emails: emails,\n    addresses: addresses,\n    response_time_ms: responseTime,\n    ...providerPayload,\n    input_first_name: request.first_name,\n    input_last_name: request.last_name,\n    input_address: request.address,\n    input_city: request.city,\n    input_state: request.state,\n    input_zip: request.zip\n  }\n}];"
      },
      "id": "parse-response",
      "name": "Parse Response",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [2000, 100]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO skip_trace_results (\n  lead_id, queue_id, provider_id, provider_name,\n  input_first_name, input_last_name, input_address, input_city, input_state, input_zip,\n  status, confidence_score, phones, emails, addresses,\n  melissa_payload, truetrace_payload, spokeo_payload, propstream_payload,\n  response_time_ms, cost\n)\nVALUES (\n  :lead_id::UUID, :queue_id::UUID, :provider_id::UUID, :provider_name,\n  :input_first_name, :input_last_name, :input_address, :input_city, :input_state, :input_zip,\n  :status, :confidence_score, :phones::JSONB, :emails::JSONB, :addresses::JSONB,\n  :melissa_payload::JSONB, :truetrace_payload::JSONB, :spokeo_payload::JSONB, :propstream_payload::JSONB,\n  :response_time_ms, 0.10\n)\nRETURNING id",
        "options": {}
      },
      "id": "save-result",
      "name": "Save Result",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.2,
      "position": [2220, 100],
      "credentials": {
        "postgres": {
          "id": "supabase_postgres",
          "name": "Supabase Postgres"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT record_skip_trace_attempt(:queue_id::UUID, :provider_id::UUID, :status, NULL, 0.10)",
        "options": {}
      },
      "id": "record-attempt",
      "name": "Record Attempt",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.2,
      "position": [2440, 100],
      "credentials": {
        "postgres": {
          "id": "supabase_postgres",
          "name": "Supabase Postgres"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "conditions": [
            {
              "id": "is-success",
              "leftValue": "={{ $('parse-response').first().json.status }}",
              "rightValue": "success",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ]
        }
      },
      "id": "check-success",
      "name": "Check Success",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2660, 100]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE leads\nSET \n  phone = COALESCE(:phones::JSONB->>0, phone),\n  email = COALESCE(:emails::JSONB->>0, email),\n  enrichment_data = COALESCE(enrichment_data, '{}'::JSONB) || jsonb_build_object(\n    'skip_trace_provider', :provider_name,\n    'skip_trace_confidence', :confidence_score,\n    'skip_trace_date', NOW(),\n    'phones', :phones::JSONB,\n    'emails', :emails::JSONB\n  ),\n  updated_at = NOW()\nWHERE id = :lead_id::UUID",
        "options": {}
      },
      "id": "update-lead",
      "name": "Update Lead",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.2,
      "position": [2880, 50],
      "credentials": {
        "postgres": {
          "id": "supabase_postgres",
          "name": "Supabase Postgres"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "const result = $('parse-response').first().json;\nconsole.log(`Skip trace ${result.status} for lead ${result.lead_id} via ${result.provider_name}`);\nreturn [{ json: { success: true } }];"
      },
      "id": "log-completion",
      "name": "Log Completion",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [3100, 50]
    },
    {
      "parameters": {
        "functionCode": "// Will retry with next provider automatically on next run\nconst request = $('prepare-request').first().json;\nconsole.log(`Skip trace incomplete for queue ${request.queue_id}, will retry with next provider`);\nreturn [{ json: { retry: true } }];"
      },
      "id": "mark-for-retry",
      "name": "Mark for Retry",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [2880, 150]
    },
    {
      "parameters": {
        "functionCode": "const error = $input.first().error;\nconst request = $('prepare-request').first().json;\n\nreturn [{\n  json: {\n    queue_id: request.queue_id,\n    provider_id: request.provider_id,\n    error_message: error.message || 'API call failed'\n  }\n}];"
      },
      "id": "handle-error",
      "name": "Handle API Error",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1780, 300],
      "continueOnFail": true
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT record_skip_trace_attempt(:queue_id::UUID, :provider_id::UUID, 'failed', :error_message, 0)",
        "options": {}
      },
      "id": "record-error",
      "name": "Record Error",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.2,
      "position": [2000, 300],
      "credentials": {
        "postgres": {
          "id": "supabase_postgres",
          "name": "Supabase Postgres"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE skip_trace_queue SET status = 'failed', error_message = :error_message WHERE id = :queue_id::UUID",
        "options": {}
      },
      "id": "mark-failed-no-provider",
      "name": "Mark Failed (No Provider)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.2,
      "position": [1780, 200],
      "credentials": {
        "postgres": {
          "id": "supabase_postgres",
          "name": "Supabase Postgres"
        }
      }
    }
  ],
  "connections": {
    "schedule-trigger": {
      "main": [[{ "node": "get-pending-traces", "type": "main", "index": 0 }]]
    },
    "get-pending-traces": {
      "main": [[{ "node": "check-has-items", "type": "main", "index": 0 }]]
    },
    "check-has-items": {
      "main": [[{ "node": "split-requests", "type": "main", "index": 0 }]]
    },
    "split-requests": {
      "main": [[{ "node": "select-provider", "type": "main", "index": 0 }], [{ "node": "log-completion", "type": "main", "index": 0 }]]
    },
    "select-provider": {
      "main": [[{ "node": "prepare-request", "type": "main", "index": 0 }]]
    },
    "prepare-request": {
      "main": [[{ "node": "has-provider", "type": "main", "index": 0 }]]
    },
    "has-provider": {
      "main": [
        [{ "node": "call-skip-trace-api", "type": "main", "index": 0 }],
        [{ "node": "mark-failed-no-provider", "type": "main", "index": 0 }]
      ]
    },
    "call-skip-trace-api": {
      "main": [[{ "node": "parse-response", "type": "main", "index": 0 }]]
    },
    "parse-response": {
      "main": [[{ "node": "save-result", "type": "main", "index": 0 }]]
    },
    "save-result": {
      "main": [[{ "node": "record-attempt", "type": "main", "index": 0 }]]
    },
    "record-attempt": {
      "main": [[{ "node": "check-success", "type": "main", "index": 0 }]]
    },
    "check-success": {
      "main": [
        [{ "node": "update-lead", "type": "main", "index": 0 }],
        [{ "node": "mark-for-retry", "type": "main", "index": 0 }]
      ]
    },
    "update-lead": {
      "main": [[{ "node": "log-completion", "type": "main", "index": 0 }]]
    },
    "mark-for-retry": {
      "main": [[{ "node": "split-requests", "type": "main", "index": 0 }]]
    },
    "call-skip-trace-api": {
      "error": [[{ "node": "handle-error", "type": "main", "index": 0 }]]
    },
    "handle-error": {
      "main": [[{ "node": "record-error", "type": "main", "index": 0 }]]
    },
    "record-error": {
      "main": [[{ "node": "split-requests", "type": "main", "index": 0 }]]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2025-10-07T00:00:00.000Z",
  "versionId": "1"
}

